#!/usr/bin/with-contenv bash

function get_ldap_base_dn() {
  # if BASE_DN is empty set value from DOMAIN
  if [ -z "$BASE_DN" ]; then
    IFS='.' read -ra BASE_DN_TABLE <<< "$DOMAIN"
    for i in "${BASE_DN_TABLE[@]}"; do
      EXT="dc=$i,"
      BASE_DN=$BASE_DN$EXT
    done

    IFS='.' read -a domain_elems <<< "${DOMAIN}"
    SUFFIX=""
    ROOT=""

    for elem in "${domain_elems[@]}" ; do
        if [ "x${SUFFIX}" = x ] ; then
            SUFFIX="dc=${elem}"
            ROOT="${elem}"
        fi
    done

    BASE_DN=${BASE_DN::-1}
  fi
}

function is_new_schema() {
  local COUNT=$(ldapsearch -Q -Y EXTERNAL -H ldapi:/// -b cn=schema,cn=config cn | grep -c $1)
  if [ "$COUNT" -eq 0 ]; then
    echo 1
  else
    echo 0
  fi
}

function ldap_add_or_modify (){
  local LDIF_FILE=$1
  print_notice "Processing file ${LDIF_FILE}"
  sed -i "s|<BASE_DN>|${BASE_DN}|g" $LDIF_FILE
  sed -i "s|<BACKEND>|${BACKEND}|g" $LDIF_FILE
  if [ "${READONLY_USER,,}" == "true" ]; then
    sed -i "s|<READONLY_USER_USER>|${READONLY_USER_USER}|g" $LDIF_FILE
    sed -i "s|<READONLY_USER_PASS_ENCRYPTED>|${READONLY_USER_PASS_ENCRYPTED}|g" $LDIF_FILE
  fi
  if grep -iq changetype $LDIF_FILE ; then
      silent ldapmodify -Y EXTERNAL -Q -H ldapi:/// -f $LDIF_FILE
  else
      silent ldapadd -Y EXTERNAL -Q -H ldapi:/// -f $LDIF_FILE 
  fi
}

function schema2ldif (){
  SCHEMAS=$1

# Dual Schema Support
  if [ "$SCHEMA_TYPE" = "rfc2307bis" ] || [ "$SCHEMA_TYPE" = "RFC2307BIS" ]; then
    cp -R /assets/slapd/config/bootstrap/schema/rfc2307bis/rfc2307bis.schema /etc/openldap/schema/
    SCHEMA_TYPE="rfc2307bis"
  else
    SCHEMA_TYPE="nis"
  fi

  tmpd=`mktemp -d`
  pushd ${tmpd} >>/dev/null

  echo "include /etc/openldap/schema/core.schema" >> convert.dat
  echo "include /etc/openldap/schema/cosine.schema" >> convert.dat
  echo "include /etc/openldap/schema/${SCHEMA_TYPE}.schema" >> convert.dat
  echo "include /etc/openldap/schema/inetorgperson.schema" >> convert.dat

  for schema in ${SCHEMAS} ; do
      echo "include ${schema}" >> convert.dat
  done

  silent slaptest -f convert.dat -F .

  if [ $? -ne 0 ] ; then
      print_error "slaptest conversion failed!"
      exit
  fi

  for schema in ${SCHEMAS} ; do
      fullpath=${schema}
      schema_name=`basename ${fullpath} .schema`
      schema_dir=`dirname ${fullpath}`
      ldif_file=${schema_name}.ldif

      find . -name *\}${schema_name}.ldif -exec mv '{}' ./${ldif_file} \;

      # TODO: these sed invocations could all be combined
      sed -i "/dn:/ c dn: cn=${schema_name},cn=schema,cn=config" ${ldif_file}
      sed -i "/cn:/ c cn: ${schema_name}" ${ldif_file}
      sed -i '/structuralObjectClass/ d' ${ldif_file}
      sed -i '/entryUUID/ d' ${ldif_file}
      sed -i '/creatorsName/ d' ${ldif_file}
      sed -i '/createTimestamp/ d' ${ldif_file}
      sed -i '/entryCSN/ d' ${ldif_file}
      sed -i '/modifiersName/ d' ${ldif_file}
      sed -i '/modifyTimestamp/ d' ${ldif_file}

      # slapd seems to be very sensitive to how a file ends. There should be no blank lines.
      sed -i '/^ *$/d' ${ldif_file}

      mv ${ldif_file} ${schema_dir}
  done

  popd >>/dev/null
  rm -rf $tmpd
}
